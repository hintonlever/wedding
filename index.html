<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Save the Date | Alina & Ben</title>

    <!-- iOS/Safari compatibility -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="Alina & Ben">
    <meta name="format-detection" content="telephone=no">

    <!-- Theme color for browser chrome -->
    <meta name="theme-color" content="#fef9f6">

    <!-- Open Graph tags for Messenger/Facebook link previews -->
    <meta property="og:type" content="website">
    <meta property="og:title" content="Save the Date | Alina & Ben">
    <meta property="og:description" content="Join us for our wedding celebration on 29.08.2026 at Great Keppel Island, Australia">
    <meta property="og:image" content="preview.png">
    <meta property="og:url" content="https://alinaandben.com">

    <!-- Twitter Card tags -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Save the Date | Alina & Ben">
    <meta name="twitter:description" content="Join us for our wedding celebration on 29.08.2026 at Great Keppel Island, Australia">
    <meta name="twitter:image" content="preview.png">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;500&family=Roboto+Flex:wght@200;300;400&display=swap" rel="stylesheet">
    <style>
        @font-face {
            font-family: 'De Lionist';
            src: url('de-lionist.otf') format('opentype');
            font-weight: normal;
            font-style: normal;
        }

        :root {
            /* ==========================================
               ASPECT RATIO - Defines main-container shape
               ========================================== */
            --w: 9;
            --h: 16;

            /* Main container dimensions - computed by JavaScript */
            --main-width: 100svw;
            --main-width: 100vw; /* Fallback */
            --main-height: 100svh;
            --main-height: 100vh; /* Fallback */

            /* ==========================================
               SIZE RATIOS - All relative to main-container
               Easy to adjust these values
               ========================================== */
            /* Envelope ratios */
            --envelope-width-ratio: 0.98;      /* 95% of main-container width */
            --envelope-height-ratio: 0.35;     /* 40% of main-container height when closed */

            /* Card ratios */
            --card-width-ratio: 0.95;          /* 90% of main-container width */
            --card-height-closed-ratio: 0.32;  /* 40% of main-container height when closed */
            --card-height-open-ratio: 0.95;    /* 90% of main-container height when fully opened */

            /* Video ratios */
            --video-width-ratio: 0.95;         /* 90% of main-container width */
            --video-height-ratio: 0.95;        /* 90% of main-container height */

            /* Seal ratio */
            --seal-size-ratio: 0.20;           /* 10% of main-container width */

            /* Global row height for elements outside the grid (26 rows) */
            --row-height-global: calc(var(--main-height) * 0.95 / 26);


           
            --font-script: 'De Lionist', cursive;
            --font-script-secondary: 'Roboto Flex', sans-serif;


            /* ==========================================
               COLORS
               ========================================== */

            --color-background: #fef9f6;
            --color-information: #fef9f6;
            --color-location: #21131d;
            --color-names: #21131d;
            --color-ampersand: #21131d;
            --color-seal: #cc5496;


            /* Envelope colors - configurable */
            --envelope-back: #d4c4b5;
            --envelope-front: #e8ddd4;
            --envelope-flap: #f0e6dc;
            --envelope-inner: #c9b9a8;

            /* Scroll length - computed by JavaScript based on main-container height */
            /* Ratios: step1→2: 0.5, step2→3: 0.5, step3→4: 0.5, step4→5: 2.0 = 3.5 total */
            --scroll-length: 350svh; /* Fallback, overridden by JS */
            --scroll-length: 350vh; /* Fallback for browsers without svh */

            /* Scroll hint position from bottom of screen */
            --scroll-hint-bottom: 10%;

            /* ==========================================
               Z-INDEX LAYERS
               ========================================== */
            --z-envelope-back: 1;
            --z-card: 5;
            --z-envelope-front: 8;         /* Side flaps and front flap - in front of card */
            --z-envelope-flap-closed: 10;  /* Top flap on top when closed */
            --z-envelope-flap-open: 4;     /* Top flap behind card when open */
            --z-seal-close: 12;           /* should be on top of the envelope */
            --z-seal-open:-1;             /* should be under the envelope */

            /* ==========================================
               INITIAL POSITIONS (CSS fallbacks)
               JavaScript computes and overrides these
               ========================================== */
            --envelope-step1-x: 50%;
            --envelope-step1-y: 50%;
            --envelope-step1-width: 95%;
            --envelope-step1-height: 40%;
            --card-step1-x: 50%;
            --card-step1-y: 50%;
            --card-step1-width: 90%;
            --card-step1-height: 40%;
            --video-step1-x: 50%;
            --video-step1-y: 50%;
            --video-step1-width: 90%;
            --video-step1-height: 90%;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            height: 100%;
            /* iOS smooth scrolling */
            -webkit-overflow-scrolling: touch;
        }

        body {
            font-family: var(--font-script-secondary);
            font-weight: 200;
            background: var(--color-background);
            color: var(--color-names);
            min-height: 100%;
            /* Prevent iOS text size adjustment */
            -webkit-text-size-adjust: 100%;
            /* Safe area padding for notched iPhones */
            padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
        }

        /* Scroll container - creates scroll space */
        .scroll-container {
            position: relative;
            /* Total scroll length = 100vh (viewport) + this value */
            /* e.g., 400vh means you scroll 3x the viewport height */
            min-height: var(--scroll-length, 350vh);
            /* iOS touch scrolling */
            -webkit-overflow-scrolling: touch;
            touch-action: pan-y;
        }

        /* Envelope scene - sticky viewport container that centers main-container */
        .envelope-scene {
            position: sticky;
            top: 0;
            width: 100%;
            height: 100svh; /* svh = small viewport height, stable on mobile */
            height: 100vh; /* Fallback for browsers without svh support */

            @supports (height: 100svh) {
                height: 100svh;
            }
            display: flex;
            align-items: center;
            justify-content: center;
            -webkit-perspective: 1500px;
            perspective: 1500px;
            overflow: hidden;
        }

        /* Main container - aspect ratio constrained box */
        .main-container {
            position: relative;
            width: var(--main-width);
            height: var(--main-height);
            /* Debug: uncomment to see bounds */
            /* outline: 2px dashed rgba(255,0,0,0.3); */
        }

        /* ==========================================
           LAYER ORDER (bottom to top):
           1. Envelope back layer (behind card)
           2. Card
           3. Envelope front layer (sides, flaps, seal)
           ========================================== */

        /* Envelope back layer - sits BEHIND the card */
        .envelope-back-layer {
            position: absolute;
            width: var(--envelope-width, var(--envelope-step1-width));
            height: var(--envelope-height, var(--envelope-step1-height));
            left: var(--envelope-x, var(--envelope-step1-x));
            top: var(--envelope-y, var(--envelope-step1-y));
            transform: translate(-50%, -50%);
            background: var(--envelope-back);
            border-radius: 4px;
            box-shadow: 0 15px 50px rgba(0,0,0,0.2);
            z-index: var(--z-envelope-back);
            transition: opacity 0.4s ease;
        }

        /* Inner shadow overlay on back layer */
        .envelope-back-layer::after {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            background: linear-gradient(180deg, var(--envelope-inner) 0%, transparent 30%);
            border-radius: 4px;
        }

        /* Envelope front layer - sides and flaps */
        .envelope-wrapper {
            position: absolute;
            width: var(--envelope-width, var(--envelope-step1-width));
            height: var(--envelope-height, var(--envelope-step1-height));
            left: var(--envelope-x, var(--envelope-step1-x));
            top: var(--envelope-y, var(--envelope-step1-y));
            transform: translate(-50%, -50%);
            z-index: var(--z-envelope-front);
        }

        /* Top flap z-index changes from closed (on top) to open (behind) */
        .envelope-top-flap {
            z-index: var(--flap-z, var(--z-envelope-flap-closed));
        }

        /* Card - decorative border frame that overlays the video */
        .card {
            position: absolute;
            width: var(--card-width, var(--card-step1-width));
            height: var(--card-height, var(--card-step1-height));
            left: var(--card-x, var(--card-step1-x));
            top: var(--card-y, var(--card-step1-y));
            transform: translate(-50%, -50%);
            border-radius: 6px;
            z-index: calc(var(--z-card) + 1);
            pointer-events: none;
            overflow: hidden;
        }

        .card-video-bg {
            position: absolute;
            /* Video position relative to main-container - card acts as clip window */
            left: var(--video-x, var(--video-step1-x));
            top: var(--video-y, var(--video-step1-y));
            width: var(--video-width, var(--video-step1-width));
            height: var(--video-height, var(--video-step1-height));
            transform: translate(-50%, -50%);
            z-index: var(--z-card);
            border-radius: 6px;
            /* Clip path calculated by JS to match card bounds */
            -webkit-clip-path: var(--video-clip);
            clip-path: var(--video-clip);
        }

        /* 25-row grid overlay for text inside white rectangle */
        .video-text-grid {
            position: absolute;
            inset: 10px;
            display: grid;
            grid-template-rows: repeat(26, minmax(0, 1fr));
            z-index: 1;
            pointer-events: none;
            /* Enable container queries for responsive text */
            container-type: size;
            /* Row height fallback for browsers without container query support */
            --row-height: calc((100vh * 0.95 - 20px) / 26);
        }

        /* Override with container query units when supported */
        @supports (height: 1cqh) {
            .video-text-grid {
                --row-height: calc(100cqh / 26);
            }
        }

        /* Dark gradient at bottom for text legibility */
        .video-text-grid::before {
            content: '';
            position: absolute;
            bottom: -10px;
            left: -10px;
            right: -10px;
            height: calc(25% + 10px);
            background: linear-gradient(to top,
             rgba(0, 0, 0, 80%) 30%, /* Bottom of the gradient */
             rgba(0, 0, 0, 0%) 100%);
            pointer-events: none;
            z-index: -1;
        }

        .grid-row {
            display: flex;
            align-items: flex-end;  /* Align to bottom of row */
            justify-content: center;
            text-align: center;
            /* 1lh = 4cqh = 1 row height */
            line-height: var(--row-height);
            /* Debug: uncomment to see grid lines */
            /* border-bottom: 1px solid rgba(255,255,255,0.1); */
        }

        /* Text styles for grid - hidden initially, fade in with card */
        .video-text-grid .save-the-date-text,
        .video-text-grid .date-text,
        .video-text-grid .name,
        .video-text-grid .card-ampersand,
        .video-text-grid .card-location,
        .video-text-grid .card-information {
            opacity: 0;
            filter: blur(6px);
            transition: opacity 0.8s cubic-bezier(0.4, 0, 0.2, 1),
                        transform 0.8s cubic-bezier(0.4, 0, 0.2, 1),
                        filter 0.8s cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* Staggered delays */
        .video-text-grid .save-the-date-text { transition-delay: 0s; }
        .video-text-grid .date-text { transition-delay: 0.1s; }
        .video-text-grid .name-1 { transition-delay: 0.2s; }
        .video-text-grid .card-ampersand { transition-delay: 0.3s; }
        .video-text-grid .name-2 { transition-delay: 0.4s; }
        .video-text-grid .card-location { transition-delay: 0.5s; }
        .video-text-grid .card-information { transition-delay: 0.6s; }

        /* Text visible state */
        .text-visible .video-text-grid .save-the-date-text,
        .text-visible .video-text-grid .date-text,
        .text-visible .video-text-grid .name,
        .text-visible .video-text-grid .card-location,
        .text-visible .video-text-grid .card-information {
            opacity: 1;
            filter: blur(0);
        }

        .text-visible .video-text-grid .card-ampersand {
            opacity: 1;
            filter: blur(0);
        }

        /* Grid text typography - using calc with --row-height for better browser compatibility */
        .video-text-grid .save-the-date-text {
            font-size: calc(var(--row-height) * 0.6);
            line-height: 1;
            color: var(--color-information);
            letter-spacing: 0.35em;
            text-transform: uppercase;
        }

        .video-text-grid .date-text {
            font-size: calc(var(--row-height) * 0.6);
            line-height: 1;
            color: var(--color-information);
            letter-spacing: 0.35em;
        }

        .video-text-grid .name {
            font-family: var(--font-script);
            font-weight: 400;
            font-size: calc(var(--row-height) * 2);
            line-height: 1;
            color: var(--color-names);

        }

        .video-text-grid .card-ampersand {
            font-family: var(--font-script);
            font-size: calc(var(--row-height) * 0.75);
            line-height: 1;
            color: var(--color-ampersand);
            font-style: italic;
            align-self: center;
            transform: translateY(calc(var(--row-height) * -0.5));

        }

        .video-text-grid .card-location {
            font-size: calc(var(--row-height) * 0.6);
            line-height: 1;
            color: var(--color-location);
            letter-spacing: 0.35em;
            text-transform: uppercase;
        }

        .video-text-grid .card-information {
            font-size: calc(var(--row-height) * 0.6);
            line-height: 1;
            color: var(--color-information);
            margin: 0;

        }

      

        /* Bleed shadow overlay - fades in at step 4 */
        .card-bleed-shadow {
            position: absolute;
            left: var(--card-x, var(--card-step4-x));
            top: var(--card-y, var(--card-step4-y));
            width: var(--card-width, var(--card-step4-width));
            height: var(--card-height, var(--card-step4-height));
            transform: translate(-50%, -50%);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.001);
            box-shadow:
                0 0 60px 20px rgba(0, 0, 0, 0.20),
                0 0 100px 40px rgba(0, 0, 0, 0.10);
            opacity: var(--bleed-opacity, 0);
            z-index: calc(var(--z-card) - 1);
            pointer-events: none;
        }

        .card-video-bg video {
            width: 120%;
            height: 100%;
            object-fit: cover;
            transform: translateX(-15%);
            /* iOS video fixes */
            -webkit-transform: translateX(-15%);
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
        }

        /* Card decorative border - now positioned over video */
        .card::after {
            content: '';
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            bottom: 10px;
            border: 2px solid var(--color-information);
            border-radius: 4px;
            pointer-events: none;
            box-shadow: 0 0 8px 10px rgba(0, 0, 0, 0.4);
        }

        /* Side flaps (left and right triangles) */
        .envelope-side-left {
            position: absolute;
            width: 50%;
            height: 100%;
            left: 0;
            top: 0;
            background: var(--envelope-front);
            clip-path: polygon(0 0, 0 100%, 100% 50%);
            transition: opacity 0.4s ease;
            z-index: var(--z-envelope-front);
        }

        .envelope-side-right {
            position: absolute;
            width: 50%;
            height: 100%;
            right: 0;
            top: 0;
            background: var(--envelope-front);
            clip-path: polygon(100% 0, 100% 100%, 0 50%);
            transition: opacity 0.4s ease;
            z-index: var(--z-envelope-front);
        }

        /* Bottom/front flap (V pointing up) */
        .envelope-front-flap {
            position: absolute;
            width: 100%;
            height: 75%;
            bottom: 0;
            left: 0;
            background: linear-gradient(0deg, var(--envelope-front) 0%, var(--envelope-flap) 100%);
            clip-path: polygon(0 100%, 50% 15%, 100% 100%);
            border-radius: 0 0 4px 4px;
            transition: opacity 0.4s ease;
            z-index: var(--z-envelope-front);
        }

        /* Top flap (opens upward) - positioned independently for z-index control */
        .envelope-top-flap {
            position: absolute;
            width: var(--envelope-width, var(--envelope-step1-width));
            height: calc(var(--envelope-height, var(--envelope-step1-height)) * 0.7);
            left: var(--envelope-x, var(--envelope-step1-x));
            top: calc(var(--envelope-y, var(--envelope-step1-y)) - var(--envelope-height, var(--envelope-step1-height)) / 2);
            transform: translateX(-50%) rotateX(var(--flap-rotation, 0deg));
            transform-origin: center top;
            -webkit-transform-style: preserve-3d;
            transform-style: preserve-3d;
            background: linear-gradient(180deg, var(--envelope-flap) 0%, var(--envelope-front) 100%);
            clip-path: polygon(0 0, 100% 0, 60% 80%, 59% 82%, 58% 83.6%, 57% 85.1%, 56% 86.4%, 55% 87.5%, 54% 88.4%, 53% 89.1%, 52% 89.6%, 51% 89.9%, 50% 90%, 49% 89.9%, 48% 89.6%, 47% 89.1%, 46% 88.4%, 45% 87.5%, 44% 86.4%, 43% 85.1%, 42% 83.6%, 41% 82%, 40% 80%);
            transition: opacity 0.4s ease;
            z-index: var(--flap-z, var(--z-envelope-flap-closed));
        }

        /* Shadow cast by the flap onto the envelope body */
        .envelope-wrapper::before {
            content: '';
            position: absolute;
            top: 0;
            left: 10%;
            right: 10%;
            height: 30%;
            background: linear-gradient(180deg,
                rgba(0, 0, 0, 0.25) 0%,
                rgba(0, 0, 0, 0.1) 40%,
                transparent 100%);
            opacity: var(--flap-shadow-opacity, 0);
            filter: blur(6px);
            pointer-events: none;
            z-index: calc(var(--z-envelope-front) - 1);
        }

        /* Wax seal - positioned at flap tip, rotates with flap */
        .wax-seal {
            position: absolute;
            width: calc(var(--main-width) * var(--seal-size-ratio));
            height: calc(var(--main-width) * var(--seal-size-ratio));
            /* Position computed by JavaScript */
            left: var(--seal-x);
            top: var(--seal-y);
            border-radius: 50%;
            background: radial-gradient(circle at 35% 35%,
                var(--color-seal) 0%,
                var(--color-seal) 40%,
                var(--color-seal) 100%);
            box-shadow:
                0 3px 12px rgba(0, 0, 0, 0.3),
                inset 0 2px 4px rgba(255,255,255,0.3),
                inset 0 -2px 4px rgba(0,0,0,0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            -webkit-transform-style: preserve-3d;
            transform-style: preserve-3d;
            transform-origin: center center;
            /* Rotate to match flap angle, scale for perspective */
            transform: translate(-50%, -50%) rotateX(var(--seal-rotation-x, 0deg)) scale(var(--seal-scale, 1));
            opacity: var(--seal-opacity, 1);
            z-index: var(--seal-z, var(--z-envelope-flap-closed));
        }

        .wax-seal::before {
            content: 'A & B';
            font-family: var(--font-script);
            font-size: calc(var(--row-height-global) * 0.3);
            color: var(--color-information);
            /* letter-spacing: 0.02em; */
            text-shadow: 0 1px 2px rgba(0,0,0,0.2);
            white-space: nowrap;
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
        }

        /* Scroll hint */
        .scroll-hint {
            position: fixed;
            bottom: var(--scroll-hint-bottom);
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            color: var(--color-names);
            font-family: var(--font-script-secondary);
            font-size: calc(var(--row-height-global) * 0.5);
            line-height: 1;
            letter-spacing: 0.35em;
            text-transform: uppercase;
            opacity: var(--hint-opacity, 1);
            transition: opacity 0.3s ease;
        }

        .scroll-icon {
            width: 28px;
            height: 42px;
            border: 2px solid var(--color-names);
            border-radius: 14px;
            position: relative;
        }

        .scroll-icon::before {
            content: '';
            position: absolute;
            top: 8px;
            left: 50%;
            transform: translateX(-50%);
            width: 4px;
            height: 8px;
            background: var(--color-seal);
            border-radius: 2px;
            animation: scroll-bounce 1.5s ease-in-out infinite;
        }

        @keyframes scroll-bounce {
            0%, 100% { top: 8px; opacity: 1; }
            50% { top: 20px; opacity: 0.5; }
        }

        /* Envelope fades when fully open */
        .envelope-wrapper.envelope-hidden .envelope-side-left,
        .envelope-wrapper.envelope-hidden .envelope-side-right,
        .envelope-wrapper.envelope-hidden .envelope-front-flap {
            opacity: 0;
        }

        .envelope-back-layer.envelope-hidden,
        .envelope-top-flap.envelope-hidden {
            opacity: 0;
        }

        /* Debug overlay */
        .debug-overlay {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: #0f0;
            font-family: monospace;
            font-size: 12px;
            padding: 10px 15px;
            border-radius: 4px;
            z-index: 9999;
            pointer-events: none;
            line-height: 1.6;
            display: none;
        }

        .debug-overlay.visible {
            display: block;
        }

        .debug-overlay .label {
            color: #888;
        }

        .debug-overlay .step-highlight {
            color: #ff0;
            font-weight: bold;
        }

        /* Debug mode: red borders on all divs */
        body.debug-mode div {
            outline: 1px solid rgba(255, 0, 0, 0.5);
        }

        /* Responsive adjustments */
        @media (max-width: 480px) {
            .card-content {
                inset: 8%; /* Slightly tighter on mobile */
            }

            .scroll-hint {
                bottom: 10%;
                font-size: 0.65rem;
            }

            .info-box {
                padding: 2rem 1.5rem;
            }
        }
    </style>
</head>
<body>
    <!-- Debug overlay (toggle with 'D' key or triple-tap) -->
    <div class="debug-overlay" id="debugOverlay">
        <div><span class="label">Version:</span> <span id="debugVersion">v1.0.0</span></div>
        <div><span class="label">Viewport:</span> <span id="debugViewport">0x0</span></div>
        <div><span class="label">Card:</span> <span id="debugCard">0x0</span> <span id="debugCardRatio"></span></div>
        <div><span class="label">Row-H:</span> <span id="debugRowHeight">0px</span></div>
        <div><span class="label">Font:</span> <span id="debugFont">0px</span> <span id="debugFontExpected"></span></div>
        <div><span class="label">Step:</span> <span class="step-highlight" id="debugStep">1</span> → <span id="debugToStep">2</span> (<span id="debugT">0%</span>)</div>
    </div>

    <!-- Scroll container -->
    <div class="scroll-container">
        <!-- Envelope scene (sticky) -->
        <div class="envelope-scene">
            <!-- Main container - aspect ratio constrained -->
            <div class="main-container" id="mainContainer">
                <!-- Video layer - clipped to card bounds -->
                <div class="card-video-bg" id="videoBg">
                    <video autoplay muted loop playsinline>
                        <source src="keppel_sunset_light.mp4" type="video/mp4">
                    </video>
                    <!-- 25-row grid overlay for text (inside white rectangle) -->
                    <div class="video-text-grid">
                        <div class="grid-row row-1"></div>
                        <div class="grid-row row-2"></div>
                        <div class="grid-row row-3">
                            <p class="save-the-date-text">Save the Date</p>
                        </div>
                        <div class="grid-row row-4">
                            <p class="date-text">29.08.2026</p>
                        </div>
                        <div class="grid-row row-5"></div>
                        <div class="grid-row row-6"></div>
                        <div class="grid-row row-7"></div>
                        <div class="grid-row row-8"></div>
                        <div class="grid-row row-9">
                     
                        </div>
                        <div class="grid-row row-10">
                            <span class="name name-1">Alina</span>
                        </div>
                        <div class="grid-row row-11">
                        </div>
                        <div class="grid-row row-12">
                                <span class="card-ampersand">&</span>
                        </div>
                        <div class="grid-row row-13">
                        </div>
                        <div class="grid-row row-14">
                        </div>
                        <div class="grid-row row-15">
                                 <span class="name name-2">Ben</span>
                        </div>
                        <div class="grid-row row-16">
                       
                        </div>
                        <div class="grid-row row-17">
                            
                        </div>
                        <div class="grid-row row-18">
                        <p class="card-location">Great Keppel</p>
                        </div>
                        <div class="grid-row row-19">
                            <p class="card-location">Island</p>
                        </div>
                        <div class="grid-row row-20"></div>
                        <div class="grid-row row-21">
              
                        </div>
                        <div class="grid-row row-22">
                            
                        </div>
                        <div class="grid-row row-23">
                 
                        </div>
                        <div class="grid-row row-24">
                            <p class="card-information">We are excited to celebrate with you!</p>
                        </div>
                        <div class="grid-row row-25">
                            <p class="card-information">Rooms are held, booking details to come soon.</p>
                        </div>
                        <div class="grid-row row-26"></div>
                    </div>
                </div>

                <!-- Bleed shadow for card (fades in at step 4) -->
                <div class="card-bleed-shadow" id="cardBleedShadow"></div>

                <!-- Card (clip mask for video) -->
                <div class="card" id="card"></div>

                <!-- Envelope back layer (separate for z-index control) -->
                <div class="envelope-back-layer" id="envelopeBack"></div>

                <div class="envelope-wrapper" id="envelope">
                    <!-- Side flaps -->
                    <div class="envelope-side-left"></div>
                    <div class="envelope-side-right"></div>

                    <!-- Front flap (bottom V) -->
                    <div class="envelope-front-flap"></div>
                </div>

                <!-- Top flap (separate for independent z-index control) -->
                <div class="envelope-top-flap" id="envelopeTopFlap"></div>

                <!-- Wax seal (separate for independent z-index control) -->
                <div class="wax-seal" id="waxSeal"></div>
            </div>

        </div>

        <!-- Scroll hint (positioned relative to viewport, outside envelope-scene to avoid perspective clipping) -->
        <div class="scroll-hint">
            <div class="scroll-icon"></div>
            <span>Scroll to open</span>
        </div>
    </div>

    <script>
        // ==========================================
        // CONFIGURATION
        // ==========================================
        //
        // 4-Step Animation:
        // Step 1: Card inside envelope (seal breaks, flap starts opening)
        // Step 2: Envelope fully open, flap z changes to behind card
        // Step 3: Card pulled out to 35vh, envelope moves to 75vh
        // Step 4: Envelope fades, card centers and grows
        //
        // ==========================================

        const CONFIG = {
            // Flap animation (step 1 to step 2) - seal follows flap
            flap: { start: 0.05, end: 0.25 },
            // Hint fade
            hintFade: { start: 0, end: 0.08 },

            // Main animation timing (4 steps within this range)
            card: {
                start: 0.10,
                end: 0.95
            },

            // Flap rotation (seal rotates with flap)
            flapRotationEnd: -180
        };

        // ==========================================
        // UTILITY FUNCTIONS
        // ==========================================
        function lerp(start, end, t) {
            return start + (end - start) * t;
        }

        // Cache for CSS variable ratios (read once, reuse)
        let cachedRatios = null;
        function getRatios() {
            if (!cachedRatios) {
                cachedRatios = {
                    envelopeWidth: parseFloat(getCSSVar('--envelope-width-ratio')) || 0.95,
                    envelopeHeight: parseFloat(getCSSVar('--envelope-height-ratio')) || 0.40,
                    cardWidth: parseFloat(getCSSVar('--card-width-ratio')) || 0.90,
                    cardHeightClosed: parseFloat(getCSSVar('--card-height-closed-ratio')) || 0.40,
                    cardHeightOpen: parseFloat(getCSSVar('--card-height-open-ratio')) || 0.90,
                    videoWidth: parseFloat(getCSSVar('--video-width-ratio')) || 0.90,
                    videoHeight: parseFloat(getCSSVar('--video-height-ratio')) || 0.90
                };
            }
            return cachedRatios;
        }

        // Parse a CSS value to pixels (handles simple units, min/max, and calc with CSS vars)
        function cssToPixels(value, containerWidth, containerHeight) {
            const str = String(value).trim();
            const ratios = getRatios();

            // Handle calc() expressions with CSS variables
            if (str.startsWith('calc(')) {
                // Extract the expression inside calc()
                let expr = str.slice(5, -1);

                // Replace CSS variables with actual values
                expr = expr.replace(/var\(--main-width\)/g, containerWidth);
                expr = expr.replace(/var\(--main-height\)/g, containerHeight);
                expr = expr.replace(/var\(--envelope-width-ratio\)/g, ratios.envelopeWidth);
                expr = expr.replace(/var\(--envelope-height-ratio\)/g, ratios.envelopeHeight);
                expr = expr.replace(/var\(--card-width-ratio\)/g, ratios.cardWidth);
                expr = expr.replace(/var\(--card-height-closed-ratio\)/g, ratios.cardHeightClosed);
                expr = expr.replace(/var\(--card-height-open-ratio\)/g, ratios.cardHeightOpen);
                expr = expr.replace(/var\(--video-width-ratio\)/g, ratios.videoWidth);
                expr = expr.replace(/var\(--video-height-ratio\)/g, ratios.videoHeight);

                // Evaluate the expression
                try {
                    return eval(expr);
                } catch (e) {
                    console.warn('Failed to evaluate calc:', str, e);
                    return 0;
                }
            }

            // Handle min() or max()
            const minMaxMatch = str.match(/^(min|max)\((.+)\)$/);
            if (minMaxMatch) {
                const fn = minMaxMatch[1];
                const args = minMaxMatch[2].split(',').map(s => cssToPixels(s.trim(), containerWidth, containerHeight));
                return fn === 'min' ? Math.min(...args) : Math.max(...args);
            }

            // Handle simple values like "50vh", "90vw", "100px", "50%"
            const match = str.match(/^(-?[\d.]+)(vw|vh|px|%)?$/);
            if (!match) return 0;

            const num = parseFloat(match[1]);
            const unit = match[2] || 'px';

            switch(unit) {
                case 'vw': return num / 100 * window.innerWidth;
                case 'vh': return num / 100 * window.innerHeight;
                case '%': return num / 100 * containerWidth; // % relative to container width
                case 'px': return num;
                default: return num;
            }
        }

        function lerpUnits(start, end, t, containerWidth, containerHeight) {
            // Convert both values to pixels, interpolate, return as px
            const startPx = cssToPixels(start, containerWidth, containerHeight);
            const endPx = cssToPixels(end, containerWidth, containerHeight);
            const resultPx = lerp(startPx, endPx, t);
            return resultPx + 'px';
        }

        function clamp(value, min, max) {
            return Math.min(Math.max(value, min), max);
        }

        function getProgress(scroll, start, end) {
            if (scroll <= start) return 0;
            if (scroll >= end) return 1;
            return (scroll - start) / (end - start);
        }

        // Easing functions
        function easeOutCubic(t) {
            return 1 - Math.pow(1 - t, 3);
        }

        function easeInOutCubic(t) {
            return t < 0.5
                ? 4 * t * t * t
                : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }

        // ==========================================
        // GET CSS VARIABLE VALUES
        // ==========================================
        function getCSSVar(name) {
            return getComputedStyle(document.documentElement).getPropertyValue(name).trim();
        }

        // ==========================================
        // SCROLL HANDLER
        // ==========================================
        const envelope = document.getElementById('envelope');
        const envelopeBack = document.getElementById('envelopeBack');
        const envelopeTopFlap = document.getElementById('envelopeTopFlap');
        const waxSeal = document.getElementById('waxSeal');
        const card = document.getElementById('card');
        const videoBg = document.getElementById('videoBg');
        const cardBleedShadow = document.getElementById('cardBleedShadow');
        const mainContainer = document.getElementById('mainContainer');
        const scrollContainer = document.querySelector('.scroll-container');
        const scrollHint = document.querySelector('.scroll-hint');

        function updateAnimation() {
            const scrollTop = window.scrollY;
            const maxScroll = scrollContainer.offsetHeight - window.innerHeight;
            const scrollProgress = clamp(scrollTop / maxScroll, 0, 1);

            // --- Flap animation ---
            const flapProgress = easeInOutCubic(getProgress(scrollProgress, CONFIG.flap.start, CONFIG.flap.end));
            const flapRotation = lerp(0, CONFIG.flapRotationEnd, flapProgress);
            envelopeTopFlap.style.setProperty('--flap-rotation', flapRotation + 'deg');

            // --- Flap shadow (peaks around 25-50% open, fades after) ---
            // Shadow is strongest when flap is between 45-90 degrees
            const flapShadowOpacity = Math.sin(flapProgress * Math.PI) * 0.8;
            envelope.style.setProperty('--flap-shadow-opacity', flapShadowOpacity);

            // --- Seal rotation matches flap ---
            waxSeal.style.setProperty('--seal-rotation-x', flapRotation + 'deg');
            // Scale peaks at halfway (90°) to simulate moving towards viewer
            const sealScale = 1 + 0.4 * Math.sin(flapProgress * Math.PI);
            waxSeal.style.setProperty('--seal-scale', sealScale);

            // Store flap rotation in radians for seal position calculation
            const flapAngleRad = flapRotation * Math.PI / 180;

            // --- Compute main-container dimensions from aspect ratio ---
            const aspectW = parseFloat(getCSSVar('--w')) || 9;
            const aspectH = parseFloat(getCSSVar('--h')) || 16;
            const vw = window.innerWidth;
            const vh = window.innerHeight;

            // Fit container in viewport while maintaining aspect ratio
            const mainWidth = Math.min(vw, vh * aspectW / aspectH);
            const mainHeight = mainWidth * aspectH / aspectW;

            // Update CSS variables for main-container and scroll length
            document.documentElement.style.setProperty('--main-width', mainWidth + 'px');
            document.documentElement.style.setProperty('--main-height', mainHeight + 'px');
            // Scroll length: 0.5 + 0.5 + 0.5 + 2.0 = 3.5 * mainHeight
            document.documentElement.style.setProperty('--scroll-length', (mainHeight * 3.5) + 'px');

            // --- Get ratios from CSS ---
            const ratios = getRatios();

            // --- 5-Step Animation ---
            const animProgress = getProgress(scrollProgress, CONFIG.card.start, CONFIG.card.end);

            // Compute step values directly from ratios (all in pixels)
            const steps = {
                envelope: {
                    1: { x: mainWidth * 0.5, y: mainHeight * 0.5, w: mainWidth * ratios.envelopeWidth, h: mainHeight * ratios.envelopeHeight },
                    2: { x: mainWidth * 0.5, y: mainHeight * 0.5, w: mainWidth * ratios.envelopeWidth, h: mainHeight * ratios.envelopeHeight },
                    3: { x: mainWidth * 0.5, y: mainHeight * 0.75, w: mainWidth * ratios.envelopeWidth, h: mainHeight * ratios.envelopeHeight },
                    4: { x: mainWidth * 0.5, y: mainHeight * 0.9, w: mainWidth * ratios.envelopeWidth, h: mainHeight * ratios.envelopeHeight },
                    5: { x: mainWidth * 0.5, y: mainHeight * 0.9, w: mainWidth * ratios.envelopeWidth, h: mainHeight * ratios.envelopeHeight }
                },
                card: {
                    1: { x: mainWidth * 0.5, y: mainHeight * 0.5, w: mainWidth * ratios.cardWidth, h: mainHeight * ratios.cardHeightClosed },
                    2: { x: mainWidth * 0.5, y: mainHeight * 0.5, w: mainWidth * ratios.cardWidth, h: mainHeight * ratios.cardHeightClosed },
                    3: { x: mainWidth * 0.5, y: mainHeight * 0.35, w: mainWidth * ratios.cardWidth, h: mainHeight * ratios.cardHeightClosed },
                    4: { x: mainWidth * 0.5, y: mainHeight * 0.5, w: mainWidth * ratios.cardWidth, h: mainHeight * ratios.cardHeightOpen },
                    5: { x: mainWidth * 0.5, y: mainHeight * 0.5, w: mainWidth * ratios.cardWidth, h: mainHeight * ratios.cardHeightOpen }
                },
                video: {
                    1: { x: mainWidth * 0.5, y: mainHeight * 0.5, w: mainWidth * ratios.videoWidth, h: mainHeight * ratios.videoHeight },
                    2: { x: mainWidth * 0.5, y: mainHeight * 0.5, w: mainWidth * ratios.videoWidth, h: mainHeight * ratios.videoHeight },
                    3: { x: mainWidth * 0.5, y: mainHeight * 0.5, w: mainWidth * ratios.videoWidth, h: mainHeight * ratios.videoHeight },
                    4: { x: mainWidth * 0.5, y: mainHeight * 0.5, w: mainWidth * ratios.videoWidth, h: mainHeight * ratios.videoHeight },
                    5: { x: mainWidth * 0.5, y: mainHeight * 0.5, w: mainWidth * ratios.videoWidth, h: mainHeight * ratios.videoHeight }
                }
            };

            // Step boundaries (ratios of total scroll)
            const s1 = 0.5, s2 = 0.5, s3 = 0.5, s4 = 2.0;
            const totalScroll = s1 + s2 + s3 + s4;
            const step2Start = s1 / totalScroll;
            const step3Start = (s1 + s2) / totalScroll;
            const step4Start = (s1 + s2 + s3) / totalScroll;

            // Determine current step and interpolation
            let fromStep, toStep, t;
            if (animProgress <= step2Start) {
                fromStep = 1; toStep = 2;
                t = easeInOutCubic(animProgress / step2Start);
            } else if (animProgress <= step3Start) {
                fromStep = 2; toStep = 3;
                t = easeInOutCubic((animProgress - step2Start) / (step3Start - step2Start));
            } else if (animProgress <= step4Start) {
                // Step 3 → Step 4 (envelope fades, card centers)
                fromStep = 3; toStep = 4;
                t = easeInOutCubic((animProgress - step3Start) / (step4Start - step3Start));
            } else {
                // Step 4 → Step 5 (final state)
                fromStep = 4; toStep = 5;
                t = easeInOutCubic((animProgress - step4Start) / (1 - step4Start));
            }

            // Interpolate envelope (values already in pixels)
            const envX = lerp(steps.envelope[fromStep].x, steps.envelope[toStep].x, t) + 'px';
            const envY = lerp(steps.envelope[fromStep].y, steps.envelope[toStep].y, t) + 'px';
            const envW = lerp(steps.envelope[fromStep].w, steps.envelope[toStep].w, t) + 'px';
            const envH = lerp(steps.envelope[fromStep].h, steps.envelope[toStep].h, t) + 'px';

            // Interpolate card
            const cardX = lerp(steps.card[fromStep].x, steps.card[toStep].x, t) + 'px';
            const cardY = lerp(steps.card[fromStep].y, steps.card[toStep].y, t) + 'px';
            const cardW = lerp(steps.card[fromStep].w, steps.card[toStep].w, t) + 'px';
            const cardH = lerp(steps.card[fromStep].h, steps.card[toStep].h, t) + 'px';

            // Interpolate video
            const vidX = lerp(steps.video[fromStep].x, steps.video[toStep].x, t) + 'px';
            const vidY = lerp(steps.video[fromStep].y, steps.video[toStep].y, t) + 'px';
            const vidW = lerp(steps.video[fromStep].w, steps.video[toStep].w, t) + 'px';
            const vidH = lerp(steps.video[fromStep].h, steps.video[toStep].h, t) + 'px';

            // Apply envelope properties to all envelope layers
            envelope.style.left = envX;
            envelope.style.top = envY;
            envelope.style.width = envW;
            envelope.style.height = envH;
            envelopeBack.style.left = envX;
            envelopeBack.style.top = envY;
            envelopeBack.style.width = envW;
            envelopeBack.style.height = envH;
            // Top flap follows envelope position
            envelopeTopFlap.style.setProperty('--envelope-x', envX);
            envelopeTopFlap.style.setProperty('--envelope-y', envY);
            envelopeTopFlap.style.setProperty('--envelope-width', envW);
            envelopeTopFlap.style.setProperty('--envelope-height', envH);
            // Wax seal position - calculate based on flap rotation
            // Flap hinge is at top edge of envelope
            const envXPx = parseFloat(envX);
            const envYPx = parseFloat(envY);
            const envHPx = parseFloat(envH);
            const flapHeight = envHPx * 0.7; // Flap is 70% of envelope height
            const flapTipOffset = flapHeight * 0.87; // Tip is at 87% down the flap (matching clip-path: 50% 87%)

            // Hinge position (top edge of envelope)
            const hingeY = envYPx - envHPx / 2;

            // Calculate seal position as flap rotates around hinge
            // When flap rotates by angle θ around X axis:
            // - Y position: hingeY + flapTipOffset * cos(θ)
            // - The seal moves up as flap opens (cos decreases as angle increases)
            const sealX = envXPx;
            const sealY = hingeY + flapTipOffset * Math.cos(flapAngleRad);

            waxSeal.style.setProperty('--seal-x', sealX + 'px');
            waxSeal.style.setProperty('--seal-y', sealY + 'px');

            // Apply card properties
            card.style.setProperty('--card-x', cardX);
            card.style.setProperty('--card-y', cardY);
            card.style.setProperty('--card-width', cardW);
            card.style.setProperty('--card-height', cardH);

            // Apply bleed shadow properties (follows card position)
            cardBleedShadow.style.setProperty('--card-x', cardX);
            cardBleedShadow.style.setProperty('--card-y', cardY);
            cardBleedShadow.style.setProperty('--card-width', cardW);
            cardBleedShadow.style.setProperty('--card-height', cardH);

            // Apply video properties (video is fixed to screen, clipped to card)
            videoBg.style.setProperty('--video-x', vidX);
            videoBg.style.setProperty('--video-y', vidY);
            videoBg.style.setProperty('--video-width', vidW);
            videoBg.style.setProperty('--video-height', vidH);

            // Calculate clip-path to clip video to card bounds
            // Video center is at (vidX, vidY), card center is at (cardX, cardY)
            // Clip-path inset(top right bottom left) relative to video element
            // Card top-left: (cardX - cardW/2, cardY - cardH/2)
            // Card bottom-right: (cardX + cardW/2, cardY + cardH/2)
            // Video top-left: (vidX - vidW/2, vidY - vidH/2)
            // Video bottom-right: (vidX + vidW/2, vidY + vidH/2)
            // Inset from video edge to card edge:
            //   top = cardTop - videoTop = (cardY - cardH/2) - (vidY - vidH/2)
            //   left = cardLeft - videoLeft = (cardX - cardW/2) - (vidX - vidW/2)
            //   bottom = videoBottom - cardBottom = (vidY + vidH/2) - (cardY + cardH/2)
            //   right = videoRight - cardRight = (vidX + vidW/2) - (cardX + cardW/2)
            const clipTop = `calc(${cardY} - ${cardH} / 2 - ${vidY} + ${vidH} / 2)`;
            const clipRight = `calc(${vidX} + ${vidW} / 2 - ${cardX} - ${cardW} / 2)`;
            const clipBottom = `calc(${vidY} + ${vidH} / 2 - ${cardY} - ${cardH} / 2)`;
            const clipLeft = `calc(${cardX} - ${cardW} / 2 - ${vidX} + ${vidW} / 2)`;
            videoBg.style.setProperty('--video-clip', `inset(${clipTop} ${clipRight} ${clipBottom} ${clipLeft} round 6px)`);

            // --- Video/card z-index: highest during step 3 (card pulling out) ---
            if (animProgress > step3Start && animProgress <= step4Start) {
                videoBg.style.zIndex = '20';
                card.style.zIndex = '21';
            } else {
                videoBg.style.zIndex = '';
                card.style.zIndex = '';
            }

            // --- Flap z-index change at step 2 ---
            // When flap is fully open (after step 1→2), change z to be behind card
            if (animProgress > step2Start) {
                envelopeTopFlap.style.setProperty('--flap-z', getCSSVar('--z-envelope-flap-open'));
            } else {
                envelopeTopFlap.style.setProperty('--flap-z', getCSSVar('--z-envelope-flap-closed'));
            }

            // --- Seal z-index: behind flap after halfway open ---
            if (flapProgress > 0.5) {
                waxSeal.style.setProperty('--seal-z', getCSSVar('--z-seal-open'));
            } else {
                waxSeal.style.setProperty('--seal-z', getCSSVar('--z-seal-closed'));
            }

            // --- Envelope fade (step 3→4) - fades as card centers ---
            const envelopeFadeProgress = getProgress(animProgress, step3Start, step4Start);
            envelope.style.opacity = 1 - envelopeFadeProgress;
            envelopeBack.style.opacity = 1 - envelopeFadeProgress;
            envelopeTopFlap.style.opacity = 1 - envelopeFadeProgress;
            waxSeal.style.setProperty('--seal-opacity', 1 - envelopeFadeProgress);

            // --- Bleed shadow fade in (step 3→4) ---
            cardBleedShadow.style.opacity = envelopeFadeProgress;

            // --- Hint fade ---
            const hintOpacity = 1 - getProgress(scrollProgress, CONFIG.hintFade.start, CONFIG.hintFade.end);
            scrollHint.style.opacity = hintOpacity;

            // --- Card text fade in (halfway between step 3 and 4) ---
            const textTrigger = step3Start + (step4Start - step3Start) * 0.5;
            if (animProgress > textTrigger) {
                videoBg.classList.add('text-visible');
            } else {
                videoBg.classList.remove('text-visible');
            }

            // --- Set row height from JavaScript for cross-browser consistency ---
            // This overrides CSS calculations which may vary between browsers
            const videoTextGrid = document.querySelector('.video-text-grid');
            if (videoTextGrid) {
                const gridRect = videoTextGrid.getBoundingClientRect();
                const rowHeightPx = gridRect.height / 26;
                videoTextGrid.style.setProperty('--row-height', rowHeightPx + 'px');
            }

            // --- Update debug overlay ---
            updateDebug(scrollProgress, animProgress, fromStep, toStep, t, flapRotation);
        }

        // ==========================================
        // DEBUG MODE
        // ==========================================
        // Version number - update this when deploying changes
        const VERSION = 'v1.0.5';

        // Set to true to show debug overlay, or press 'D' to toggle, or triple-tap on mobile
        let DEBUG_MODE = false;

        const debugOverlay = document.getElementById('debugOverlay');
        const debugStep = document.getElementById('debugStep');
        const debugToStep = document.getElementById('debugToStep');
        const debugT = document.getElementById('debugT');
        const debugVersion = document.getElementById('debugVersion');
        const debugViewport = document.getElementById('debugViewport');
        const debugCard = document.getElementById('debugCard');
        const debugCardRatio = document.getElementById('debugCardRatio');
        const debugRowHeight = document.getElementById('debugRowHeight');
        const debugFont = document.getElementById('debugFont');
        const debugFontExpected = document.getElementById('debugFontExpected');
        const videoTextGrid = document.querySelector('.video-text-grid');
        const infoText = document.querySelector('.card-information');

        // Set version on load
        debugVersion.textContent = VERSION;

        function updateDebug(scrollProgress, animProgress, fromStep, toStep, t, flapRotation) {
            if (!DEBUG_MODE) return;
            debugStep.textContent = fromStep;
            debugToStep.textContent = toStep;
            debugT.textContent = (t * 100).toFixed(0) + '%';
            debugViewport.textContent = window.innerWidth + 'x' + window.innerHeight;
            // Show actual card dimensions and aspect ratio
            const cardRect = card.getBoundingClientRect();
            const cardW = Math.round(cardRect.width);
            const cardH = Math.round(cardRect.height);
            debugCard.textContent = cardW + 'x' + cardH;
            // Calculate and show aspect ratio (w:h simplified)
            const ratio = cardH / cardW;
            debugCardRatio.textContent = '(1:' + ratio.toFixed(2) + ')';
            // Show computed row height
            const computedRowHeight = getComputedStyle(videoTextGrid).getPropertyValue('--row-height');
            debugRowHeight.textContent = computedRowHeight || 'N/A';
            // Show actual vs expected font size to detect min-font clamping
            if (infoText) {
                const actualFont = getComputedStyle(infoText).fontSize;
                const rowHeightNum = parseFloat(computedRowHeight);
                const expectedFont = (rowHeightNum * 0.6).toFixed(1) + 'px';
                debugFont.textContent = actualFont;
                debugFontExpected.textContent = '(exp: ' + expectedFont + ')';
            }
        }

        function toggleDebug() {
            DEBUG_MODE = !DEBUG_MODE;
            debugOverlay.classList.toggle('visible', DEBUG_MODE);
            document.body.classList.toggle('debug-mode', DEBUG_MODE);
            if (DEBUG_MODE) updateAnimation(); // Refresh debug display
        }

        // Toggle with 'D' key
        window.addEventListener('keydown', (e) => {
            if (e.key === 'd' || e.key === 'D') {
                toggleDebug();
            }
        });

        // Triple-tap to toggle debug on mobile
        let tapCount = 0;
        let tapTimeout = null;
        document.addEventListener('touchend', (e) => {
            // Only count single-finger taps
            if (e.changedTouches.length !== 1) return;

            tapCount++;
            if (tapCount === 3) {
                toggleDebug();
                tapCount = 0;
                clearTimeout(tapTimeout);
            } else {
                clearTimeout(tapTimeout);
                tapTimeout = setTimeout(() => { tapCount = 0; }, 400);
            }
        }, { passive: true });

        // Listen to scroll with requestAnimationFrame for smoother iOS performance
        let ticking = false;
        window.addEventListener('scroll', function() {
            if (!ticking) {
                window.requestAnimationFrame(function() {
                    updateAnimation();
                    ticking = false;
                });
                ticking = true;
            }
        }, { passive: true });

        // Listen to resize (recalculate on viewport change)
        window.addEventListener('resize', updateAnimation, { passive: true });

        // iOS video autoplay fix - ensure video plays on user interaction
        const video = document.querySelector('video');
        if (video) {
            // Attempt to play video (may fail on iOS without interaction)
            video.play().catch(function() {
                // If autoplay fails, play on first touch
                document.addEventListener('touchstart', function playVideo() {
                    video.play();
                    document.removeEventListener('touchstart', playVideo);
                }, { once: true, passive: true });
            });
        }

        // Initial state
        updateAnimation();
    </script>
</body>
</html>
